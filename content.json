[{"title":"唐巧《ios开发进阶》笔记","date":"2017-03-28T12:29:11.000Z","path":"2017/03/28/唐巧《ios开发进阶》笔记/","text":"之前书读的很多。但是感觉没有有效的记录一些有用的东西，现在开始记录一些我认为的重点。方便以后查找。 阅后小感买这本书时还出处于刚开始进阶。我觉得这本书对于刚开始进阶的人还有所有用处的。因为这本书虽然涉及面广，所涉及的深度并没有太深。而且知识点也有点老。 就连巧神也说。他这本书现在太旧了。不适合购买。 实用工具篇在这里简述了很多实用的工具。简单做下简介。 CocoaPods这个实在太普遍了。项目中使用也是很方便。但仍然有一些人喜欢使用手动集成的方法。具体介绍网上太多。不详细写了。 关于 pod install 和 pod update 书中没有写。之前有个学弟和我说起这个。但是感觉理解是错误的。所以做个记号。 pod install 表示，如果有 Podfile.lock 文件，则更新为 Podfile.lock 内指定版本的库文件，如果没有 pod.lock 文件，则更新到网络上最新的库 pod update 表示无视 Podfile.lock 文件。将库文件更新到最新库的版本 Charles 抓包工具使用简介在唐巧的博客 上有,应该是目前网上最全的 Charles 教程。 Reveal 界面调试工具很强大的解析 app 界面的工具。有了它。就可以知道一些大的app的布局是怎么样的。但是前提是设备需要越狱。目前手上没有已越狱的设备。还没试过。等下次越狱的时候再做记录。 一些日志收集和统计工具国内这两年用友盟用的比较多。知道这些工具之后还是拓展了下知识面。 Xcode 插件Xcode 8 已经不支持插件了。网上有些偏门的方法来做到使用插件。但是我也不太习惯。如果硬是要用的话。可以退回到 Xcode 7 的版本。 还有些其他工具很细小。不做列举 开发UIWindow 使用UIWindow 继承自 UIView 所以它包含所有 UIView 的特性，其作用有以下2点： 作为顶层容器，来包含所有的 View 传递触摸消息给其他的 View UIWindow 的层级并不是所有新建的 UIWindow 都是在最顶层的。UIWindow 有 UIWindowLevel 属性，来设置它的显示位置 不能滥用 UIWindow ，如果不是为了在所有页面上都显示一个 View 的话。尽量不要使用 UIWindow 不然新创建的 UIWindow 会得不到释放。 类似于MBProgress 组件，会让你指定一个显示 View ，用于更好的显示 动态下载字体苹果官方提供了一部分特殊的中文字体。可以通过应用内下载的方式集成到 app 中。 应用内安全除了使用 https 以外，对于隐私和敏感数据的保护尤为重要。总结如下几点： 用户密码明文形式很容易通过 Charels 来截取，应该通过加密公钥和私钥的方式来获取。服务器使用私钥解码后，再加盐后多次 md5 。 对通信协议进行加密。可以保证协议不会被轻易读取出来。（Protobuf 谷歌提供的开源数据交换格式） 对于一些配置数据，我们不应该直接把它们放在资源文件中。（例如 js 文件）应该进行适当加密 对于一些用户数据，我们更应该加他们使用 keychain 保护起来。 对于反编译，或许采取一些混淆的反汇编手段会来的更好。 比较重要的小技巧在书中第18章中列举了很多小技巧。这里只记录几个我觉得比较重要。并且实用性比较高的 Daily Build 在 唐巧的博客 中也有。添加Daily Build 真的是件很幸福的事。希望以后有机会我能多尝试一些脚本语言来进行一些处理日常事务上的事 代码片段管理。 书中介绍了配置自己的代码片段。但是会不会配合 Alare 操作起来会更好？ 快捷键。更推荐趣直播 张星宇 的直播。大大提升开发效率。 最后，本书中还有包括 内存管理 、GDC 、 底层开发 都放到了后续《 iOS 与 OS X 多线程和内存管理》一书中详解。还有一部分 CoreText 排版引擎 后续有机会整理出来单独写一篇。这个可以学习的东西还有很多。","tags":[]},{"title":"Masnory与自动布局的故事","date":"2017-03-16T12:29:45.000Z","path":"2017/03/16/Masnory/","text":"前段时间太忙。没有时间更新，把之前整理的东西再拿出来好好整理一遍。这篇主要接上文。整理一下Masnory的使用。 前言使用苹果自带的xib或者storyboard必然有很多方便的地方，但是仍然有时无法避免有些做不到的事情，或者做起来没有那么方便的事情，这时候代码布局就显得很重要了。关于Masnory的教程，网上有很多，这里先列举一些。 学习官方文档总是没有错的 CocoaChina 的 Masnory 教程 在这里，简单总结一些Masnory的方法，以及一些不太用到的方法。 简单使用在阅读完并完成相关安装步骤后，可以先从Masnory类的方法和属性来看起。 方法先是3个基础方法。 12345678//设置约束- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;//更新约束- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;//重新设置约束- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block; 使用如下 1234567891011121314151617 _businessLabel = [UILabel new]; [self addSubview:_businessLabel]; //设置约束 [_businessLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;//设置一些约束 &#125;]; //更新约束 [_businessLabel mas_updateConstraints:^(MASConstraintMaker *make) &#123;//设置一些约束 &#125;]; //重新设置约束 [_businessLabel mas_remakeConstraints:^(MASConstraintMaker *make) &#123;//设置一些约束 &#125;]; 掌握着三个方法，基本上就能掌握日常使用的一些基本布局了 属性既然是自动布局，那其中的属性必然和storyboard中的约束有着联系，这边简单做一个的映射关系。 属性名 解释 对应autolayout left 左边距 top 上边距 right 右边距 bottom 下边距 leading 顶部边距 trailing 尾部边距 width 宽度 height 长度 centerX X轴居中 centerY Y轴居中 baseline 基准线 edges 上左下右边距 size 长和宽 center XY轴居中 例子用法：要实现如图的布局 在 xib 获取 storyboard 中可能是这样的 使用Masnory可以如下键入代码 1234567891011121314151617181920UIView *view1 = [UIView new];view1.backgroundColor = [UIColor blueColor];[self.view addSubview:view1];[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(ws.view.mas_top).offset(10); make.left.equalTo(ws.view.mas_left).offset(8); make.size.mas_equalTo(CGSizeMake(100, 100));&#125;];UIView *view2 = [UIView new];view2.backgroundColor = [UIColor yellowColor];[self.view addSubview:view2];[view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(view1.mas_top); make.left.equalTo(view1.mas_right).offset(16); make.right.equalTo(ws.view.mas_right).offset(-8); make.height.equalTo(view1.mas_height);&#125;]; 还有一些后续版本中加入的方法，是针对控制器（ViewControll）的，而不是针对 view 的。通常用于 navbar 和tabbar 相关 mas_topLayoutGuide mas_bottomLayoutGuide mas_topLayoutGuideTop mas_topLayoutGuideBottom mas_bottomLayoutGuideTop mas_bottomLayoutGuideBottom 一些比较有用的方法和属性计算公共父容器方法- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view; 该方法是在View+MASAdditions中的，因此，该方法返回的是一个UIView。从官方的注解中看，该方法是寻找两个视图的最近的公共父视图。 例如： 在 viewA 上添加 viewB 和 viewC 在 viewB 上添加 viewD 和 viewE 那么viewB 是 viewD 和 viewE 最近的公共父视图。viewA 是 viewD 和 viewC 最近的公共父视图 代码验证一下 123456789101112131415161718192021222324252627282930UIView *viewA = [UIView new];[self.view addSubview:viewA];//===========================UIView *viewB = [UIView new];[viewA addSubview:viewB];UIView *viewC = [UIView new];[viewA addSubview:viewC];//===========================UIView *viewD = [UIView new];[viewB addSubview:viewD];UIView *viewE = [UIView new];[viewB addSubview:viewE];if ([[viewD mas_closestCommonSuperview:viewE] isEqual:viewB]) &#123; NSLog(@&quot;viewB是viewD和viewE最近的父视图&quot;);&#125;else&#123; NSLog(@&quot;viewB不是viewD和viewE最近的父视图&quot;);&#125;if ([[viewD mas_closestCommonSuperview:viewC] isEqual:viewA]) &#123; NSLog(@&quot;viewA是viewD和viewC最近的父视图&quot;);&#125;else&#123; NSLog(@&quot;viewA不是viewD和viewC最近的父视图&quot;);&#125; 输出 12[10276:1157366] viewB是最近的父视图[10276:1157366] viewA是最近的父视图 intrinsicContentSize让 view 有一个默认的长和宽，他会根据约束来改变其值，类似于 UILabel 不过这也和约束优先级有关，这里 有篇文章介绍的不错。之前看到有人用它来做 UITableViewCell 的自适应，我觉得不是特别需要。如果项目需求是在 iOS8 以上的话，可以使用下面的方法来做自适应。 UITableViewAutomaticDimensioniOS8以上的项目，如果 UITableView 不是特别复杂的话，可以使用 UITableViewAutomaticDimension 来进行适配。使用方法如下。 1234567891011121314151617181920212223- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return 1;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 1;&#125;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //预测高度 return 44;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 自动计算高度 return UITableViewAutomaticDimension;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath]; return cell;&#125; 这篇先总结到这里。后面持续更新一些UI上会使用到的小技巧。","tags":[]},{"title":"AutoLayout实战（实战二）","date":"2016-09-04T08:26:40.000Z","path":"2016/09/04/autolayout实战（二）/","text":"上一篇中说了一下约束的使用方法，这篇再继续学习一下Size Classes。这个技术是在ios8之后才出现的。有限制的支持ios7。 我们先用一张图来反应一下这个东西能做出什么样的效果。 gif稍微有点卡，配合虚拟机更卡，但在真机中的效果很棒，各个元素之间的切换都是有关联的。 基础知识在正式开始实战之前，我们先了解一下Size Classes的一些基本知识和操作原理。 从上面的图我们可以看到，Size Classes主要负责设备在不同情况下的的显示效果。事实上，他不仅可以管理横竖屏的情况，甚至可以管理在各种设备上的显示效果 （ipad，iphone，ipad pro） 操作入口第一个问题肯定是从何入手：打开storyboard，我们在最下面的栏目中可以看到，wAny hAny的属性标示，点击我们就可以看到一个网格状的模块。 随意组合，就可以看到面板中的控制器(ViewController)会发生样式变化 属性知道了操作的入口，现在需要弄懂的就是各个属性代表的是什么意思了 在图中我们看到了wAny hAny,那这个是什么意思呢？如果宽度(weight)设为Any，高度(height)设置为Regular，那么在该状态下的界面元素在只要height为Regular，无论weight是Regular还是Compact的状态中都会存在。这种关系应该叫做继承关系，具体的四种界面描述与可继承的界面描述如下： w:Compact h:Compact 继承 (w:Any h:Compact , w:Compact h:Any , w:Any h:Any) w:Regular h:Compact 继承 (w:Any h:Compact , w:Regular h:Any , w:Any h:Any) w:Compact h:Regular 继承 (w:Any h:Regular , w:Compact h:Any , w:Any h:Any) w:Regular h:Regular 继承 (w:Any h:Regular , w:Regular h:Any , w:Any h:Any) 其实很好理解，就是一级一级往下。 具体与屏幕之间的联系则如下： iPhone4S,iPhone5/5s,iPhone6 竖屏：(w:Compact h:Regular) 横屏：(w:Compact h:Compact) iPhone6 Plus 竖屏：(w:Compact h:Regular) 横屏：(w:Regular h:Compact) iPad 竖屏：(w:Regular h:Regular) 横屏：(w:Regular h:Regular) 实战紧接上一篇中的例子，目前的表现是所有状态下显示的效果都是如此，但是很明显，在这种情况下，将屏幕横放时，就会出现图片显示不全的现象（不使用scrollview的情况下），这是很糟糕的用户体验，那我们现在要做的就是，对其横屏情况下进行修改，将Size Classes设置成 wAny hCompact 删除一些不必要的约束，这里注意，删除时对布局线按cmd + del，这样做的目的是，在该状态、以及其子类中删除该约束。而不删除其父类中的约束。简单的说，就是删除在横屏情况下不需要的约束。 调整布局的位置 为其添加新的属性 运行打开模拟器运行一下，按住cmd + ←(或 →)可以切换模式，在真机中也可以尝试一下，效果会比模拟器好一点。 最后很多同学都还是很喜欢手动代码布局，确实，手动代码布局的维护性会比在storyboard中更加棒，所以后面我在更新两篇我学习的手动代码布局 利用Masonry框架实现 ，当然，原生的自动布局也会提到，不过不建议使用，代码量和其复杂性太高。","tags":[]},{"title":"AutoLayout使用（实战一）","date":"2016-09-01T01:44:09.000Z","path":"2016/09/01/实战(一)/","text":"预览在开始之前，先看下我们要完成的效果图的样子。 我们的目标是打算做成这个样子的一个页面。当然，这样简单的一个页面，使用frame,我相信很多同学也很快能够完成，但是，现在，让我们用AutoLayout来看下搭建这样一个页面，到底有简单呢？ 准备AutoLayout使用的是一种相对布局，和android的RelativeLayout有着很相似的地方。接来下，先理一下思路。 这里，我用一张图来表达一下。 简单解释一下这张图： 头像部分，左边和顶部距离屏幕20个单位，头像大小固定为40x40 姓名与时间，分别与头像的顶部与底部对齐，左边距离头像15个单位 大图，距离头像20个单位，左边与右边距离屏幕20个单位（这样就固定了图片的长），之后再让其长宽相等，这样就是一个正方形的图片了 底部正文文字，左边距离屏幕20个单位，顶部距离图片20个单位。 开始知道了如何布局，那现在就开始实践吧～打开XCode,新建一个工程。打开storyboard。为了美观，可以为原有的ViewController加入一个NavigationController。接下来，将我们需要的控件拖入进来。 头部试图选中图片，点击右下角的pin按钮，对其进行约束的添加。 继续对两边的文字进行约束的添加。 主要部分选中中间的图片。对其进行约束的添加。 选中最后的文字，对其进行约束的添加。 完成现在，我们就对这样一个布局添加好约束了！给图片们添加一些属性，打开模拟器看一下，在各个屏幕中都有良好的现实效果。","tags":[]},{"title":"AutoLayout的使用","date":"2016-08-31T12:14:19.000Z","path":"2016/08/31/autolayout的使用/","text":"相信很多同学在刚接触ios开发的时候，非常熟悉这句代码 initWithFrame:CGRectMake(0, 0, 20, 20) 这是很多人刚刚开始学会布局的时候使用的一种布局方式，没错，我也是。这种布局方式很适合刚入门的开发者，frame将控件的位置用一种绝对位置的方式固定在屏幕中。如下图。 如图的例子就是将一个60x60的控件放置在 x轴座标为20，y轴座标为20的区域中。 这种方式在iPhone 4之前的年代十分合适，因为屏幕大小确定，开发者只需要确定绝对位置，就能很方便的布局了。在屏幕多样化的现在，依旧很多人使用这种方式，但是需要加入一定的计算。获取屏幕宽度，用比例去计算大小。 为什么使用AutoLayout之前也说过，使用frame的方式，难以做出很好的屏幕适配，甚至需要一定的计算量。那在现在屏幕分辨率碎片化越来越严重的时代，我们应该找到一种能一套方案，解决所有屏幕布局的方法。 没错，那就是AutoLayout。 什么是AutoLayoutAutoLayout，让开发者能用一个设计来适配所有屏幕，从理论上来说，可以做到iPhone 4到iPad pro的所有屏幕适配。当然，我这里说的是理论上，也有可能会出现意外 AutoLayout意图让开发者忘记屏幕本身的尺寸，使用任意一个画布，利用约束（constraint）来进行对各个控件之间的距离，长宽进行控制。利用上面同样一张图控件的位置，我们可以来进行对比。 如图所示，我们可以根据我们所需要的实际情况，利用不同的方式来进行对控件的约束。 相关约束属性 left right width height bottom top leading trailing centerX centerY baseLine 这里我用一张图来更加直观得反应这些约束的实际意义 有了这些属性，我们就能轻松定义控件与控件之间的关系啦！ 这里有一点值得注意，leading和trailing 这两个属性似乎与left和right很相似。确实，在大部分情况下，这两个属性的意义确实是相同的，他们存在的意义在于不同语言环境下。有些国家，或者说中国古代的书写顺序是和现在相反的，即从右往左的写法(正常情况是从左往右)。具体情况如下图。 最后简单得介绍了autolayout，图都是我自己一点点画的，希望能对autolayout的一无所知同学有一定帮助，后面我会再更新两篇文章，来结合实际开发来具体讲述下实战中的运用。","tags":[]},{"title":"我的移动开发学习","date":"2016-08-31T12:14:18.000Z","path":"2016/08/31/我的移动开发学习/","text":"现在我是一名准大四计算机学院学生，我的大学并不出色，是属于我们这边比较三流的学校，大一并没有相关专业课程，因此，我的编程生涯可以算是从大二才开始的。 这里还有个小插曲，大一的时候，我大胆得冲进一个老师的办公室，和她说“我要写代码，我要写项目。”所有的一切，都是从我开口说这句话开始。也是因为这句话，我成了她在我们这一届最骄傲的学生（后来发现她并不是我专业的老师，由于跟了她，我也在我们专业被拉入黑名单） 学习之路学习移动开发，是我刚接触智能机的时候就萌发的一个理想，现在，我能为此工作，为此学习，也十分开心。 一切从兴趣入手对于移动开发，在我们学校没有相关专业课程去教学，我的学习之旅也完全是从兴趣入手，当时我特别喜欢ios开发，但是由于学校苹果机房的限制，也听从了导师的安排，首先先开始学习了android开发。 大二由于要参加一些外包，ACM，电商竞赛，也让我不得不进入了疯狂的学习阶段，学习进度在一些学长的带领下，进步很快。 辉煌时刻非常不容易，大二的一年过的很辛苦，各种压力把我压的喘不起来，但是黄天不负苦心人，我在大二那年，也获得了不少成就，在各类省赛中，也拿到了不错的成绩。也成功成为了本届第一批免毕业设计的学生。 膨胀大二一年很快过去，我凭借着手上为数不多的项目，开始找工作，也很顺利在暑期的时候就有了第一份工作，也是在那个时候，开始接触了ios，我也深深被它所吸引，并且在公司，我的学习和上升速度很快，很快就独立完成了第一个在apple store上架的作品。那时候开始慢慢萌发了编程不过如此的想法。 盲目大三开始了，我在辅导员和朋友的鼓舞下，进入了学生干部的生涯，当上了一名部长，也成为一名主席。开始在兼顾工作的同时，监管各种学生事务，开始盲目觉得自己很强。虽然在半年的时间，我也上架了一款app。但是殊不知，我已经开始慢慢堕落了。 打击 第一次打击是在大三下的时候，我带着我的学弟学妹，和我的一个好基友开始了漫长的竞赛，但是没有想到的是，付出了比之前更多的努力，换来的是比之前更差的成绩。 第二次打击，是在一次与一位前辈的谈话中，这位前辈是从海外留学回来的，我当时的想法就是，一个项目，应该尽可能使用开源框架，来节约时间，也更方便开发者去实现，但是他给了我一个微笑，问我，“你说你很熟悉开源框架，那你读过AFNetworking的源码吗？”，说句实话，我当时傻了。 之后的打击也是数不胜数，从一些知名博客，知乎，简书，等等我也知道了很多不足。这里我也举一些例子。 对Objective-C要有足够得了解，OC是如何基于C来进行的封装？ 对于UI,稍微深一点的会了吗？比如，侧边栏的菜单滑出的原理？ 动画会了吗？为什么CALayer会产生隐式动画？ 各种安全机制懂了吗？ …. 我第一次看到上面这些问题的时候，我真的觉得打击很大，也是直到最后，我向各大公司投递简历的时候，简历石沉大海，我才明白了，我还差的很远。 醒悟现在也快大四开始了，相比较其他很多优秀的大四学生，我应该落后了不少，大三这一年，我不能说我完全荒废了，但确实没有什么大的成长，这个假期，我也在一家技术公司工作，在闲余时间，我也学习不少东西，我是因为热爱才去学习，我觉得现在醒悟还不算晚。 最后最后我想说一下，我是一个热爱编程的逗比，平时活得也比较开心，但是我是一个对应用品质很严格的人。我喜欢很多细节把控很好的应用，我也致力于打造这些细节打动用户的应用，之后我会不断更新一些我的学习心得，也会不定期奉上一些酷炫的控件。真正的学习，从现在开始。 第一次写文章，写的不好，请勿见怪。","tags":[]}]