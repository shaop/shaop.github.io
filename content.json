[{"title":"组件化之路探索：CocoaPods 私有 pods 搭建","date":"2017-10-19T14:45:21.000Z","path":"2017/10/19/组件化之路探索：CocoaPods 私有 pods 搭建/","text":"看了 n 多的组件化的方案之后，基本所有的方案都指向是有 CocoaPods 进行组件化构建。因此，本篇记录使用 CocoaPods 搭建私有 pods 的过程。 概览搭建私有 pod 步骤一般分为以下： 搭建私有的 PodSpesc 仓库 创建私有的组件库 配置私有的组件库 上传版本与版本管理 加入到私有 PodSpesc 仓库 搭建私有的 PodSpesc 仓库在搭建仓库之前，我们需要在 git 上创建一个仓库。 注意授权许可选择 MIT Licenese 创建完成之后之后输入以下命令进行 PodSpesc 仓库的创建 1$ pod repo add [REPO_NAME(仓库名字)] [SOURCE_URL(git的地址)] 创建完成之后，在本地的 /Users/username/.cocoapods/repos/ 目录下就会出现刚刚创建的 PodSpesc 仓库。 创建私有的组件库在创建完私有的 PodSpesc 仓库之后，就要开始创建我们私有的组件库了。 这里同样需要在 git 上创建仓库，不再重复。默认在git目录下操作。 创建组件库的方式有很多，这里推荐 CocoaPods 自带的创建方式，使用如下命令 1$ pod lib create XXXKit 后续有一系列选择，试实际需求确定。 创建完成之后，一般情况下的目录结构如下 123456789101112131415161718XXXKit ├── .travis.yml ├── _Pods.xcproject ├── Example │ ├── XXXKit │ ├── XXXKit.xcodeproj │ ├── XXXKit.xcworkspace │ ├── Podfile │ ├── Podfile.lock │ ├── Pods │ └── Tests ├── LICENSE ├── XXXKit.podspec ├── Pod │ ├── Assets │ └── Classes │ └── RemoveMe.[swift/m] └── README.md 至此，已经完成私有组件的创建 配置私有的组件库组件库的配置主要是配置 .podspec 文件，使用 CocoaPods 创建的内容一般都包括了主要需要的配置项。在此列举。 name ：库的名字 version：当前库的版本，需要对应 git 的 tag 号 summary：简介 description：描述，需要在&lt;&lt;-DESC 和 DESC中间填入描述 homepage：项目的官方首页 screenshots：预览图 license：许可描述 author：作者描述 source：源码地址，即 git 地址 social_media_url： 作者的媒体方式，例如微博，twitter deployment_target：iOS 的支持版本 source_files：pod 中的源码通配符地址 resource_bundles：资源通配符地址 public_header_files：头文件的通配符地址，用在闭源环境下 frameworks：使用的frameworks，例如 UIKit dependency：项目的依赖，可以加入类似 AFNetworking 等依赖，在别的工程 pod install 时会自动加入这些依赖 粗体的配置完成之后在该工程目录下输入以下命令来进行库的验证 1$ pod lib lint 上传版本与版本管理私有库的版本在 git 中使用 tag 来进行管理的 这里的逻辑是在源码版本 push 后，再打入 tag 。命令如下 1234$ git push origin master //这里的 push 是提交版本源码$ git tag '1.0.0' //这里的 tag 必须和上面提交的源码中的 .podspec 文件中的 version 相同$ git push --tags$ git push origin master 加入到私有 PodSpesc 仓库确定无误之后，即可加入先前建立的 PodSpesc 仓库了，在组件库中输入以下命令 1$ pod repo push [PodSpescName(仓库的名字)] [XXXKix.podspec(目录下的 .podspec)] 测试可用建立项目，创建 Podfile 和平时不同的是，需要在文件的最开头输入以下的 code 12source &apos;http://xxxx.xxx/XXXX/XXXPodSpesc.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos; 指明需要的库，否则 CocoaPod 无法找需要需要的库","tags":[]},{"title":"关于 autoreleasepool 在 64 位与 32 位下的引用区别","date":"2017-10-11T16:34:14.000Z","path":"2017/10/12/关于 autoreleasepool 在 64 位与 32 位下的引用区别/","text":"起因在阅读 雷纯峰 Objective-C Autorelease Pool 的实现原理 的时候，发现他其中的实验例子在一些设备上已经失效。而这些设备恰好是 64位 设备。检索了下脑海中64位与32位的区别，第一个想到的就是 Tagged Pointer。 探索怀着探索的目的，准备动手试一试。首先先看下结果。 12345678910111213141516171819202122232425262728293031323334__weak NSString *string_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 1 NSString *string = [NSString stringWithFormat:@&quot;leichunfeng&quot;]; string_weak_ = string; // 场景 2// @autoreleasepool &#123;// NSString *string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];// string_weak_ = string;// &#125; // 场景 3// NSString *string = nil;// @autoreleasepool &#123;// string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];// string_weak_ = string;// &#125; NSLog(@&quot;string: %@&quot;, string_weak_);&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@&quot;string: %@&quot;, string_weak_);&#125;- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; NSLog(@&quot;string: %@&quot;, string_weak_);&#125; 64位下输出 1234567891011121314// 场景 12017-8-26 13:38:38.291705+0800 testPro[4036:799277] string: leichunfeng2017-8-26 13:38:38.291932+0800 testPro[4036:799277] string: leichunfeng2017-8-26 13:38:38.295360+0800 testPro[4036:799277] string: leichunfeng// 场景 22017-8-26 13:44:11.657844+0800 testPro[4112:817709] string: leichunfeng2017-8-26 13:44:11.658055+0800 testPro[4112:817709] string: leichunfeng2017-8-26 13:44:11.661383+0800 testPro[4112:817709] string: leichunfeng// 场景 32017-8-26 13:45:13.864718+0800 testPro[4139:821594] string: leichunfeng2017-8-26 13:45:13.864943+0800 testPro[4139:821594] string: leichunfeng2017-8-26 13:45:13.868293+0800 testPro[4139:821594] string: leichunfeng 32位下输出 1234567891011121314// 场景 12015-05-30 10:32:20.837 AutoreleasePool[33876:1448343] string: leichunfeng2015-05-30 10:32:20.838 AutoreleasePool[33876:1448343] string: leichunfeng2015-05-30 10:32:20.845 AutoreleasePool[33876:1448343] string: (null)// 场景 22015-05-30 10:32:50.548 AutoreleasePool[33915:1448912] string: (null)2015-05-30 10:32:50.549 AutoreleasePool[33915:1448912] string: (null)2015-05-30 10:32:50.555 AutoreleasePool[33915:1448912] string: (null)// 场景 32015-05-30 10:33:07.075 AutoreleasePool[33984:1449418] string: leichunfeng2015-05-30 10:33:07.075 AutoreleasePool[33984:1449418] string: (null)2015-05-30 10:33:07.094 AutoreleasePool[33984:1449418] string: (null) 在64位下。毫无例外的都输出了结果。第一次看到的时候，完全觉得不可思议，突然想到这个其实和 NSString 直接输入字符串得到的结果是相同的。 这里牵扯到 NSString *str = @&quot;leichunfeng&quot; 不会被释放，是因为这样的话 str 是被当一个 Strinig 类型的常量 NSCFConstantString 来对待的。 但是这里都是使用工厂方法创建的类型。所以都是应该是一个实实在在的对象。结合 Tagged Pointer 我们知道，在64位下，对象的指针是会进行优化的。在 64位 代码中断点我们也可以看到这个对象确确实实是一个 NSTaggedPointerString 对象。 所以假设成立。这是由于 Tagged Pointer 引起的无法释放。那光了解到这里，显然是不够的。继续深入了解下 Tagged Pointer。 Tagged Pointer 为了优化内存，Apple 在64位设备中，引入了 Tagged Pointer 来优化 isa 指针。（64位的指针来记录地址太浪费啦～）。其中有一部分就默认了一些值NSDate,NSNumber,NSString… 照这么说，如果一个值的类型很大，那必然无法使用 Tagged Pointer 来进行优化，我对原来的代码进行一些修改。 123456789101112131415161718192021222324252627282930313233343536373839__weak NSString *string_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 1 NSString *string = [NSString stringWithFormat:@&quot;12345678900&quot;]; string_weak_ = string; // 场景 2// @autoreleasepool &#123;// NSString *string = [NSString stringWithFormat:@&quot;12345678900&quot;];// string_weak_ = string;// &#125; // 场景 3// NSString *string = nil;// @autoreleasepool &#123;// string = [NSString stringWithFormat:@&quot;12345678900&quot;];// string_weak_ = string;// &#125; NSLog(@&quot;string: %@&quot;, string_weak_);&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@&quot;string: %@&quot;, string_weak_);&#125;- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; NSLog(@&quot;string: %@&quot;, string_weak_);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning];&#125; 64位下输出 1234567891011121314// 场景 12017-8-26 15:43:23.232464+0800 testPro[5432:1104611] string: 123456789002017-8-26 15:43:23.232667+0800 testPro[5432:1104611] string: 123456789002017-8-26 15:43:23.237981+0800 testPro[5432:1104611] string: (null)// 场景 22017-10-26 15:44:08.761063+0800 testPro[5460:1109356] string: (null)2017-10-26 15:44:08.761292+0800 testPro[5460:1109356] string: (null)2017-10-26 15:44:08.766554+0800 testPro[5460:1109356] string: (null)// 场景 32017-10-26 15:44:57.918361+0800 testPro[5485:1114091] string: 123456789002017-10-26 15:44:57.918576+0800 testPro[5485:1114091] string: (null)2017-10-26 15:44:57.923708+0800 testPro[5485:1114091] string: (null) 这一下，完全可以放心了。输出的结果和 32位 下的完全一致。这就表明了。在 Tagged Pointer 下，指针默认储存着一些值。 Tagged Pointer 对应关系简单记录下 Tagged Pointer 中 isa 的指针存放。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if SUPPORT_NONPOINTER_ISA# if __arm64__# define ISA_MASK 0x00000001fffffff8ULL# define ISA_MAGIC_MASK 0x000003fe00000001ULL# define ISA_MAGIC_VALUE 0x000001a400000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000 uintptr_t magic : 9; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;;# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x0000000000000001ULL# define ISA_MAGIC_VALUE 0x0000000000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 14;# define RC_ONE (1ULL&lt;&lt;50)# define RC_HALF (1ULL&lt;&lt;13) &#125;;# else // Available bits in isa field are architecture-specific.# error unknown architecture# endif// SUPPORT_NONPOINTER_ISA#endif&#125;; isa 对应的含义 Tables Are indexed 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 has sidetable rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 该部分引用自 Objective-C 引用计数原理","tags":[]},{"title":"关于 iOS 生产模式下的错误捕捉（swift 版本）","date":"2017-09-12T09:30:38.000Z","path":"2017/09/12/关于 iOS 生产模式下的错误捕捉（swift 版本）/","text":"事件的起因是之前公司的新项目使用了 swift 进行编程，经过几个月的打磨后终于上线，上线后使用的是友盟进行缺陷的捕捉。 捕捉到的内容如下 12345678910111213141516171819202122232425262728293031323334*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil(null)(( 0 CoreFoundation 0x0000000182b05918 &lt;redacted&gt; + 148 1 libobjc.A.dylib 0x0000000182173f80 objc_exception_throw + 56 2 CoreFoundation 0x00000001829ef134 CFStringConvertNSStringEncodingToEncoding + 0 3 UIKit 0x0000000187b3a71c &lt;redacted&gt; + 208 4 UIKit 0x0000000187830210 &lt;redacted&gt; + 620 5 UIKit 0x0000000187847c58 &lt;redacted&gt; + 108 6 UIKit 0x0000000187a0d5b4 &lt;redacted&gt; + 4036 7 UIKit 0x00000001879f0114 &lt;redacted&gt; + 12824 8 UIKit 0x0000000187a0a9f8 &lt;redacted&gt; + 360 9 xxxx 0x10009e5c8 xxxx + 648648 10 xxxx 0x10009cbd4 xxxx + 642004 11 UIKit 0x000000018792df38 &lt;redacted&gt; + 1316 12 UIKit 0x00000001879ec018 &lt;redacted&gt; + 376 13 UIKit 0x0000000187aa8b70 &lt;redacted&gt; + 292 14 UIKit 0x0000000187ab6030 &lt;redacted&gt; + 92 15 UIKit 0x00000001877e9c24 &lt;redacted&gt; + 96 16 CoreFoundation 0x0000000182abc588 &lt;redacted&gt; + 32 17 CoreFoundation 0x0000000182aba32c &lt;redacted&gt; + 372 18 CoreFoundation 0x0000000182aba75c &lt;redacted&gt; + 928 19 CoreFoundation 0x00000001829e9680 CFRunLoopRunSpecific + 384 20 GraphicsServices 0x0000000183ef8088 GSEventRunModal + 180 21 UIKit 0x0000000187860d90 UIApplicationMain + 204 22 xxxx 0x100008120 xxxx + 33056 23 libdyld.dylib 0x000000018258a8b8 &lt;redacted&gt; + 4)dSYM UUID: 66FA9D06-0793-324A-A6DF-CF2399C36D0FCPU Type: arm64Slide Address: 0x0000000100000000Binary Image: xxxxBase Address: 0x0000000100094000 其中 xxxx代表项目名。 进入到该版本的 dSYM 中。终端输入。即可看到错误的位置。1atos -arch arm64 -o xxxx 0x10009e5c8","tags":[]},{"title":"关于 Jenkins 相关配置","date":"2017-07-24T11:23:13.000Z","path":"2017/07/24/关于 Jenkins 相关配置/","text":"Jenkins 作为一款持续构建的平台，毋庸置疑我们需要去了解它。在最近公司的项目中，为了简化公司的构建成本，从而引入了 Jenkins 。 这一篇。将分成搭建和配置项目两个方面来记录一下我在搭建中遇到的坑和解决方案。 搭建环境为了兼容移动产品（ iOS ）的构建，这里选择了在 macOS 上进行相关配置，这里选用的是一台公司暂时搁置的 mac mini 进行搭建。 JDK 的安装对于 Jenkins 本身而言。他是用 java 编写的，首先需要的就是 jdk 。 jdk 的安装方式有很多。我这里使用的是 Homebrew 进行安装。接下去很多的环境，我也是采用 Homebrew 进行安装。1$ brew install jdk Apple 系列产品环境对于 Apple 家族的 app（包括 iOS app ，Mac app）。需要在 macOS 环境下才能进行构建，所以这里选择了 macOS 来进行搭建环境。 针对 Apple 的产品环境构建，只需要在 app store 上面下载 Xcode 即可。 这里指的一体的是，Xcode 帮助我们省去很多不必要的麻烦。比如自带的 git 。 Android 环境搭建下载 android studio ，配置 gradle 版本。 Jenkins安装安装 Jenkins 流传着两种方法，一种是直接客户端安装，一种是命令行安装，亲身实践后，发现客户端安装会导致在配置 shell 的时候捕捉不到环境变量，不过这个可以在之后使用命令行重启来修复。这里我们直接使用命令行安装 Jenkins ，依旧使用 Homebrew 。 1$ brew install jenkins 启动找到 Jenkins 的 war 包所在目录。运行一下命令。1$ java -jar jenkins.war --httpPort=8080 其中，8080 是端口号。之后进行一系列的初始化设置就好了。 配置 iOS 工程创建一个工程输入一个项目名称，然后选择 自由风格的软件项目 即可 配置 这里简单写一些重要的步骤。 源码配置 这里使用的是公司自己的 git 。输入项目的 git 地址，然后，添加 git 相关的认证。这里推荐使用 ssh 的认证方式 如下没有出现红色的错误信息表示配置正确。 环境证书配置在具体配置构建之前，需要配置证书。这里先下载插件。Keychains and Provisioning Profiles Management 进入 Keychains and Provisioning Profiles Management 配置具体的证书。上传 login.keychain 和具体的证书。 这里关于 login.keychain 有个坑，在 macOS 10.12 之后找到的是 login.keychain-db，很多教程没有更新过来。 这样，环境证书就配置好了。 构建 这里笔者使用的是 fastlane 进行构建。 选择好的自己的刚刚倒入的证书 添加构建步骤，选择 Execute shell 如果项目有使用 CocoaPods 那此处就需要对项目首先进行一次 pod install 接下去，就是用 fastlane 进行构建。配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#指定项目的scheme名称scheme=&quot;xxx&quot;#指定要打包的配置名configuration=&quot;Adhoc&quot;#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数export_method=&apos;ad-hoc&apos;#指定项目地址workspace_path=&quot;$project_path/xxx.xcworkspace&quot;#指定输出路径output_path=&quot;/Users/xxx/Documents/xxxx&quot;#指定输出归档文件地址archive_path=&quot;$output_path/hkb_iOS_$&#123;now&#125;.xcarchive&quot;#指定输出ipa地址ipa_path=&quot;$output_path/xxxx_$&#123;now&#125;.ipa&quot;#指定输出ipa名称ipa_name=&quot;xxxx_$&#123;now&#125;.ipa&quot;#获取执行命令时的commit messagecommit_msg=&quot;$1&quot;#输出设定的变量值echo &quot;===workspace path: $&#123;workspace_path&#125;===&quot;echo &quot;===archive path: $&#123;archive_path&#125;===&quot;echo &quot;===ipa path: $&#123;ipa_path&#125;===&quot;echo &quot;===export method: $&#123;export_method&#125;===&quot;echo &quot;===commit msg: $1===&quot;#先清空前一次build#fastlane gym --workspace $&#123;workspace_path&#125; --scheme $&#123;scheme&#125; --clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;output_path&#125; --output_name $&#123;ipa_name&#125; 最后，再上传蒲公英。 1curl -F &quot;file=@$&#123;IPANAME&#125;.ipa&quot; -F &quot;uKey=xxxx&quot; -F &quot;_api_key=xxxx&quot; -F &quot;password=xxxx&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload 开始构建保存之后就可以开始构建了。等待一段时间，表示失败，表示成功。 配置 Android 工程 相比较于 iOS ，android 的构建会显得简单一点。源码配置相类似。具体从构建步骤开始 构建构建版本点击添加构建版本后，选择 Invoke Gradle scprit 填写好相应信息后即可。 具体的构建内容，需要从 android 的 gradle 文件中配置，每个项目都不一样，再次不一一列举。 最后再上传蒲公英 1curl -F &quot;file=@$xxx.apk&quot; -F &quot;uKey=xxxx&quot; -F &quot;_api_key=xxxx&quot; -F &quot;password=xxxx&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload 有一点需要说明，android 的版本构建依赖于 keystore 。这个文件不建议放在版本控制器上，建议拷贝一份放在 Jenkins 的构建源码版本中。 Endhave fun！","tags":[]},{"title":"ReactiveCocoa 学习心得","date":"2017-06-11T13:51:22.000Z","path":"2017/06/11/ReactiveCocoa 学习心得/","text":"基础认识信号：发送一个动作，让订阅这个信号的订阅者接收这些动作。只要有改变，信号内部接受数据就会马上发送数据 订阅：订阅后方可接受信号内的消息。 命令：命令一般用于网络请求，内包含一些耗时的操作。结束后发送一个信号。 一、RACSignal创建RACSignal .使用createSignal方法，可以构建一个方法，在block内部，使用subscriber(订阅者)发送信号在其他地方的signal被订阅就会接受到信号内的值。 1234567891011121314//创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;this is a signal&quot;]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot;信号在这里被终止了&quot;); &#125;];&#125;];//订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;在这里接受到信号:%@&quot;,x);&#125;]; 控制台输出 122017-01-05 21:42:36.422 learnRAC[1336:29812] 在这里接受到信号:this is a signal2017-01-05 21:42:36.423 learnRAC[1336:29812] 信号在这里被终止了 二、RACSubject使用方法RACSubject信号提供者，自己可以充当信号，又能发送信号 1234567891011121314//创建一个信号RACSubject *subject = [RACSubject subject];//订阅者接受消息[subject subscribeNext:^(id x) &#123; NSLog(@&quot;第一个订阅者在这里接收到信号:%@&quot;,x);&#125;];[subject subscribeNext:^(id x) &#123; NSLog(@&quot;第二个订阅者在这里接收到信号:%@&quot;,x);&#125;];//发送消息[subject sendNext:@&quot;一条消息&quot;]; 控制台输出122017-01-05 23:01:13.401 learnRAC[1929:88074] 第一个订阅者在这里接收到信号:一条消息2017-01-05 23:01:13.404 learnRAC[1929:88074] 第二个订阅者在这里接收到信号:一条消息 RACReplaySubjectRACReplaySubject允许先发送，后订阅。 123456789101112131415161718// 1.创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 2.发送信号[replaySubject sendNext:@1];[replaySubject sendNext:@2];// 3.订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);&#125;];// 订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);&#125;]; 这里可以总结一下 subscribeNext:方法是订阅者接受消息 sendNext:方法是订阅者发送消息 使用场景RACSubject可以用来代替delegate 。方便实现代理的功能。使用方法如下 viewController1.m 1234567-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; SecondViewController *vc = segue.destinationViewController; vc.delegate = [RACSubject subject]; [vc.delegate subscribeNext:^(id x) &#123; NSLog(@&quot;按钮被点击%@&quot;,x); &#125;];&#125; viewController2.h 12345#import &lt;UIKit/UIKit.h&gt;@interface viewController2 : UIViewController@property (nonatomic , strong) RACSubject *delegate;@end viewController2.m 12345- (IBAction)ClickAction:(id)sender &#123; if (self.delegate) &#123; [self.delegate sendNext:@&quot;this is a msg&quot;]; &#125;&#125; 控制台输出12017-01-05 22:57:55.701 learnRAC[1874:84684] 按钮被点击this is a msg 用这种方式，比直接写delegate方法要来的快得多。 三、RACCommandRACCommand从字面意思上是一个命令，其主要应用场景在于应用一些耗时的操作，例如网络操作，之后再发送一个信号，进行消息数据的传递。 例子模仿一个viewmodel的网络操作，获取数据后传递给viewController进行数据显示。viewmodel 123456789101112131415161718192021-(void)doNetWork&#123; if (self = [super init]) &#123; RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@&quot;这里执行了一段网络请求获取到的input是：%@&quot;,input); NSString *data = @&quot;返回数据&quot;; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:data]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot;销毁了信号&quot;); &#125;]; &#125;]; &#125;]; _command = command; &#125; return self;&#125; viewController 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; CommandViewModel *cmdVD = [[CommandViewModel alloc] init]; [cmdVD.command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@&quot;网络请求的数据为:%@&quot;,x); &#125;]; &#125;]; //高级用法 [cmdVD.command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;网络请求的数据为:%@&quot;,x); &#125;];&#125; 这里，还可以根据发送signal的状态定义command接收的状态。 [subscriber sendError:[[NSError alloc] init]]; 那么在接受的时候就可以使用此方法来接受错误状态 123[cmdVD.command.errors.switchToLatest subscribeNext:^(id x) &#123;//do error &#125;]; 几个有趣的实用性方法 rac_signalForSelector ：用作代替代理，实现某些Selector时需要执行的语句。 rac_valuesAndChangesForKeyPath ：用作代替KVO，对某个对象进行监听。 rac_signalForControlEvents：用作监听某些动作，比如按下按钮的这些动作。 rac_addObserverForName：用作监听某些通知，例如OC中的NSNotification。 rac_textSignal：用作监听文本框内容的变化。 rac_liftSelector:withSignalsFromArray:Signals：这是一个信号组，但是这些signals必须都被sendNext过。 几个重要的操作方法mapmap的作用：把原信号的值映射成一个新的值 123456789101112131415// 创建信号RACSubject *subject = [RACSubject subject];RACSignal *signal = [subject map:^id(id value) &#123; // 当原信号发送数据的时候就会来调用这个block,修改原信号的内容 value = @([value floatValue] +1.0); // 返回值就是修改后的原信号的内容 return value;&#125;];[signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];[subject sendNext:@&quot;999&quot;]; 返回 12017-01-06 14:11:15.024 testRAC[3121:139101] 1000 mergemerge：把多个信号合并为一个信号，任何一个信号有新值时就会调用 123456789101112131415161718RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;signalA发送完信号&quot;]; return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;signalB发送完信号&quot;]; return nil; &#125;]; // 合并信号，任何一个信号发送数据都能在订阅中监听到 RACSignal *mergesignal = [signalA merge:signalB]; [mergesignal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];","tags":[]},{"title":"唐巧《ios开发进阶》笔记","date":"2017-03-28T12:29:11.000Z","path":"2017/03/28/唐巧《ios开发进阶》笔记/","text":"之前书读的很多。但是感觉没有有效的记录一些有用的东西，现在开始记录一些我认为的重点。方便以后查找。 阅后小感买这本书时还出处于刚开始进阶。我觉得这本书对于刚开始进阶的人还有所有用处的。因为这本书虽然涉及面广，所涉及的深度并没有太深。而且知识点也有点老。 就连巧神也说。他这本书现在太旧了。不适合购买。 实用工具篇在这里简述了很多实用的工具。简单做下简介。 CocoaPods这个实在太普遍了。项目中使用也是很方便。但仍然有一些人喜欢使用手动集成的方法。具体介绍网上太多。不详细写了。 关于 pod install 和 pod update 书中没有写。之前有个学弟和我说起这个。但是感觉理解是错误的。所以做个记号。 pod install 表示，如果有 Podfile.lock 文件，则更新为 Podfile.lock 内指定版本的库文件，如果没有 pod.lock 文件，则更新到网络上最新的库 pod update 表示无视 Podfile.lock 文件。将库文件更新到最新库的版本 Charles 抓包工具使用简介在唐巧的博客 上有,应该是目前网上最全的 Charles 教程。 Reveal 界面调试工具很强大的解析 app 界面的工具。有了它。就可以知道一些大的app的布局是怎么样的。但是前提是设备需要越狱。目前手上没有已越狱的设备。还没试过。等下次越狱的时候再做记录。 一些日志收集和统计工具国内这两年用友盟用的比较多。知道这些工具之后还是拓展了下知识面。 Xcode 插件Xcode 8 已经不支持插件了。网上有些偏门的方法来做到使用插件。但是我也不太习惯。如果硬是要用的话。可以退回到 Xcode 7 的版本。 还有些其他工具很细小。不做列举 开发UIWindow 使用UIWindow 继承自 UIView 所以它包含所有 UIView 的特性，其作用有以下2点： 作为顶层容器，来包含所有的 View 传递触摸消息给其他的 View UIWindow 的层级并不是所有新建的 UIWindow 都是在最顶层的。UIWindow 有 UIWindowLevel 属性，来设置它的显示位置 不能滥用 UIWindow ，如果不是为了在所有页面上都显示一个 View 的话。尽量不要使用 UIWindow 不然新创建的 UIWindow 会得不到释放。 类似于MBProgress 组件，会让你指定一个显示 View ，用于更好的显示 动态下载字体苹果官方提供了一部分特殊的中文字体。可以通过应用内下载的方式集成到 app 中。 应用内安全除了使用 https 以外，对于隐私和敏感数据的保护尤为重要。总结如下几点： 用户密码明文形式很容易通过 Charels 来截取，应该通过加密公钥和私钥的方式来获取。服务器使用私钥解码后，再加盐后多次 md5 。 对通信协议进行加密。可以保证协议不会被轻易读取出来。（Protobuf 谷歌提供的开源数据交换格式） 对于一些配置数据，我们不应该直接把它们放在资源文件中。（例如 js 文件）应该进行适当加密 对于一些用户数据，我们更应该加他们使用 keychain 保护起来。 对于反编译，或许采取一些混淆的反汇编手段会来的更好。 比较重要的小技巧在书中第18章中列举了很多小技巧。这里只记录几个我觉得比较重要。并且实用性比较高的 Daily Build 在 唐巧的博客 中也有。添加Daily Build 真的是件很幸福的事。希望以后有机会我能多尝试一些脚本语言来进行一些处理日常事务上的事 代码片段管理。 书中介绍了配置自己的代码片段。但是会不会配合 Alare 操作起来会更好？ 快捷键。更推荐趣直播 张星宇 的直播。大大提升开发效率。 最后，本书中还有包括 内存管理 、GDC 、 底层开发 都放到了后续《 iOS 与 OS X 多线程和内存管理》一书中详解。还有一部分 CoreText 排版引擎 后续有机会整理出来单独写一篇。这个可以学习的东西还有很多。","tags":[]},{"title":"Masnory与自动布局的故事","date":"2017-03-16T12:29:45.000Z","path":"2017/03/16/Masnory/","text":"前段时间太忙。没有时间更新，把之前整理的东西再拿出来好好整理一遍。这篇主要接上文。整理一下Masnory的使用。 前言使用苹果自带的xib或者storyboard必然有很多方便的地方，但是仍然有时无法避免有些做不到的事情，或者做起来没有那么方便的事情，这时候代码布局就显得很重要了。关于Masnory的教程，网上有很多，这里先列举一些。 学习官方文档总是没有错的 CocoaChina 的 Masnory 教程 在这里，简单总结一些Masnory的方法，以及一些不太用到的方法。 简单使用在阅读完并完成相关安装步骤后，可以先从Masnory类的方法和属性来看起。 方法先是3个基础方法。 12345678//设置约束- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;//更新约束- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;//重新设置约束- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block; 使用如下 1234567891011121314151617 _businessLabel = [UILabel new]; [self addSubview:_businessLabel]; //设置约束 [_businessLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;//设置一些约束 &#125;]; //更新约束 [_businessLabel mas_updateConstraints:^(MASConstraintMaker *make) &#123;//设置一些约束 &#125;]; //重新设置约束 [_businessLabel mas_remakeConstraints:^(MASConstraintMaker *make) &#123;//设置一些约束 &#125;]; 掌握着三个方法，基本上就能掌握日常使用的一些基本布局了 属性既然是自动布局，那其中的属性必然和storyboard中的约束有着联系，这边简单做一个的映射关系。 属性名 解释 对应autolayout left 左边距 top 上边距 right 右边距 bottom 下边距 leading 顶部边距 trailing 尾部边距 width 宽度 height 长度 centerX X轴居中 centerY Y轴居中 baseline 基准线 edges 上左下右边距 size 长和宽 center XY轴居中 例子用法：要实现如图的布局 在 xib 获取 storyboard 中可能是这样的 使用Masnory可以如下键入代码 1234567891011121314151617181920UIView *view1 = [UIView new];view1.backgroundColor = [UIColor blueColor];[self.view addSubview:view1];[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(ws.view.mas_top).offset(10); make.left.equalTo(ws.view.mas_left).offset(8); make.size.mas_equalTo(CGSizeMake(100, 100));&#125;];UIView *view2 = [UIView new];view2.backgroundColor = [UIColor yellowColor];[self.view addSubview:view2];[view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(view1.mas_top); make.left.equalTo(view1.mas_right).offset(16); make.right.equalTo(ws.view.mas_right).offset(-8); make.height.equalTo(view1.mas_height);&#125;]; 还有一些后续版本中加入的方法，是针对控制器（ViewControll）的，而不是针对 view 的。通常用于 navbar 和tabbar 相关 mas_topLayoutGuide mas_bottomLayoutGuide mas_topLayoutGuideTop mas_topLayoutGuideBottom mas_bottomLayoutGuideTop mas_bottomLayoutGuideBottom 一些比较有用的方法和属性计算公共父容器方法- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view; 该方法是在View+MASAdditions中的，因此，该方法返回的是一个UIView。从官方的注解中看，该方法是寻找两个视图的最近的公共父视图。 例如： 在 viewA 上添加 viewB 和 viewC 在 viewB 上添加 viewD 和 viewE 那么viewB 是 viewD 和 viewE 最近的公共父视图。viewA 是 viewD 和 viewC 最近的公共父视图 代码验证一下 123456789101112131415161718192021222324252627282930UIView *viewA = [UIView new];[self.view addSubview:viewA];//===========================UIView *viewB = [UIView new];[viewA addSubview:viewB];UIView *viewC = [UIView new];[viewA addSubview:viewC];//===========================UIView *viewD = [UIView new];[viewB addSubview:viewD];UIView *viewE = [UIView new];[viewB addSubview:viewE];if ([[viewD mas_closestCommonSuperview:viewE] isEqual:viewB]) &#123; NSLog(@&quot;viewB是viewD和viewE最近的父视图&quot;);&#125;else&#123; NSLog(@&quot;viewB不是viewD和viewE最近的父视图&quot;);&#125;if ([[viewD mas_closestCommonSuperview:viewC] isEqual:viewA]) &#123; NSLog(@&quot;viewA是viewD和viewC最近的父视图&quot;);&#125;else&#123; NSLog(@&quot;viewA不是viewD和viewC最近的父视图&quot;);&#125; 输出 12[10276:1157366] viewB是最近的父视图[10276:1157366] viewA是最近的父视图 intrinsicContentSize让 view 有一个默认的长和宽，他会根据约束来改变其值，类似于 UILabel 不过这也和约束优先级有关，这里 有篇文章介绍的不错。之前看到有人用它来做 UITableViewCell 的自适应，我觉得不是特别需要。如果项目需求是在 iOS8 以上的话，可以使用下面的方法来做自适应。 UITableViewAutomaticDimensioniOS8以上的项目，如果 UITableView 不是特别复杂的话，可以使用 UITableViewAutomaticDimension 来进行适配。使用方法如下。 1234567891011121314151617181920212223- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return 1;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 1;&#125;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //预测高度 return 44;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 自动计算高度 return UITableViewAutomaticDimension;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath]; return cell;&#125; 这篇先总结到这里。后面持续更新一些UI上会使用到的小技巧。","tags":[]},{"title":"AutoLayout实战（实战二）","date":"2016-09-04T08:26:40.000Z","path":"2016/09/04/autolayout实战（二）/","text":"上一篇中说了一下约束的使用方法，这篇再继续学习一下Size Classes。这个技术是在ios8之后才出现的。有限制的支持ios7。 我们先用一张图来反应一下这个东西能做出什么样的效果。 gif稍微有点卡，配合虚拟机更卡，但在真机中的效果很棒，各个元素之间的切换都是有关联的。 基础知识在正式开始实战之前，我们先了解一下Size Classes的一些基本知识和操作原理。 从上面的图我们可以看到，Size Classes主要负责设备在不同情况下的的显示效果。事实上，他不仅可以管理横竖屏的情况，甚至可以管理在各种设备上的显示效果 （ipad，iphone，ipad pro） 操作入口第一个问题肯定是从何入手：打开storyboard，我们在最下面的栏目中可以看到，wAny hAny的属性标示，点击我们就可以看到一个网格状的模块。 随意组合，就可以看到面板中的控制器(ViewController)会发生样式变化 属性知道了操作的入口，现在需要弄懂的就是各个属性代表的是什么意思了 在图中我们看到了wAny hAny,那这个是什么意思呢？如果宽度(weight)设为Any，高度(height)设置为Regular，那么在该状态下的界面元素在只要height为Regular，无论weight是Regular还是Compact的状态中都会存在。这种关系应该叫做继承关系，具体的四种界面描述与可继承的界面描述如下： w:Compact h:Compact 继承 (w:Any h:Compact , w:Compact h:Any , w:Any h:Any) w:Regular h:Compact 继承 (w:Any h:Compact , w:Regular h:Any , w:Any h:Any) w:Compact h:Regular 继承 (w:Any h:Regular , w:Compact h:Any , w:Any h:Any) w:Regular h:Regular 继承 (w:Any h:Regular , w:Regular h:Any , w:Any h:Any) 其实很好理解，就是一级一级往下。 具体与屏幕之间的联系则如下： iPhone4S,iPhone5/5s,iPhone6 竖屏：(w:Compact h:Regular) 横屏：(w:Compact h:Compact) iPhone6 Plus 竖屏：(w:Compact h:Regular) 横屏：(w:Regular h:Compact) iPad 竖屏：(w:Regular h:Regular) 横屏：(w:Regular h:Regular) 实战紧接上一篇中的例子，目前的表现是所有状态下显示的效果都是如此，但是很明显，在这种情况下，将屏幕横放时，就会出现图片显示不全的现象（不使用scrollview的情况下），这是很糟糕的用户体验，那我们现在要做的就是，对其横屏情况下进行修改，将Size Classes设置成 wAny hCompact 删除一些不必要的约束，这里注意，删除时对布局线按cmd + del，这样做的目的是，在该状态、以及其子类中删除该约束。而不删除其父类中的约束。简单的说，就是删除在横屏情况下不需要的约束。 调整布局的位置 为其添加新的属性 运行打开模拟器运行一下，按住cmd + ←(或 →)可以切换模式，在真机中也可以尝试一下，效果会比模拟器好一点。 最后很多同学都还是很喜欢手动代码布局，确实，手动代码布局的维护性会比在storyboard中更加棒，所以后面我在更新两篇我学习的手动代码布局 利用Masonry框架实现 ，当然，原生的自动布局也会提到，不过不建议使用，代码量和其复杂性太高。","tags":[]},{"title":"AutoLayout使用（实战一）","date":"2016-09-01T01:44:09.000Z","path":"2016/09/01/实战(一)/","text":"预览在开始之前，先看下我们要完成的效果图的样子。 我们的目标是打算做成这个样子的一个页面。当然，这样简单的一个页面，使用frame,我相信很多同学也很快能够完成，但是，现在，让我们用AutoLayout来看下搭建这样一个页面，到底有简单呢？ 准备AutoLayout使用的是一种相对布局，和android的RelativeLayout有着很相似的地方。接来下，先理一下思路。 这里，我用一张图来表达一下。 简单解释一下这张图： 头像部分，左边和顶部距离屏幕20个单位，头像大小固定为40x40 姓名与时间，分别与头像的顶部与底部对齐，左边距离头像15个单位 大图，距离头像20个单位，左边与右边距离屏幕20个单位（这样就固定了图片的长），之后再让其长宽相等，这样就是一个正方形的图片了 底部正文文字，左边距离屏幕20个单位，顶部距离图片20个单位。 开始知道了如何布局，那现在就开始实践吧～打开XCode,新建一个工程。打开storyboard。为了美观，可以为原有的ViewController加入一个NavigationController。接下来，将我们需要的控件拖入进来。 头部试图选中图片，点击右下角的pin按钮，对其进行约束的添加。 继续对两边的文字进行约束的添加。 主要部分选中中间的图片。对其进行约束的添加。 选中最后的文字，对其进行约束的添加。 完成现在，我们就对这样一个布局添加好约束了！给图片们添加一些属性，打开模拟器看一下，在各个屏幕中都有良好的现实效果。","tags":[]},{"title":"AutoLayout的使用","date":"2016-08-31T12:14:19.000Z","path":"2016/08/31/autolayout的使用/","text":"相信很多同学在刚接触ios开发的时候，非常熟悉这句代码 initWithFrame:CGRectMake(0, 0, 20, 20) 这是很多人刚刚开始学会布局的时候使用的一种布局方式，没错，我也是。这种布局方式很适合刚入门的开发者，frame将控件的位置用一种绝对位置的方式固定在屏幕中。如下图。 如图的例子就是将一个60x60的控件放置在 x轴座标为20，y轴座标为20的区域中。 这种方式在iPhone 4之前的年代十分合适，因为屏幕大小确定，开发者只需要确定绝对位置，就能很方便的布局了。在屏幕多样化的现在，依旧很多人使用这种方式，但是需要加入一定的计算。获取屏幕宽度，用比例去计算大小。 为什么使用AutoLayout之前也说过，使用frame的方式，难以做出很好的屏幕适配，甚至需要一定的计算量。那在现在屏幕分辨率碎片化越来越严重的时代，我们应该找到一种能一套方案，解决所有屏幕布局的方法。 没错，那就是AutoLayout。 什么是AutoLayoutAutoLayout，让开发者能用一个设计来适配所有屏幕，从理论上来说，可以做到iPhone 4到iPad pro的所有屏幕适配。当然，我这里说的是理论上，也有可能会出现意外 AutoLayout意图让开发者忘记屏幕本身的尺寸，使用任意一个画布，利用约束（constraint）来进行对各个控件之间的距离，长宽进行控制。利用上面同样一张图控件的位置，我们可以来进行对比。 如图所示，我们可以根据我们所需要的实际情况，利用不同的方式来进行对控件的约束。 相关约束属性 left right width height bottom top leading trailing centerX centerY baseLine 这里我用一张图来更加直观得反应这些约束的实际意义 有了这些属性，我们就能轻松定义控件与控件之间的关系啦！ 这里有一点值得注意，leading和trailing 这两个属性似乎与left和right很相似。确实，在大部分情况下，这两个属性的意义确实是相同的，他们存在的意义在于不同语言环境下。有些国家，或者说中国古代的书写顺序是和现在相反的，即从右往左的写法(正常情况是从左往右)。具体情况如下图。 最后简单得介绍了autolayout，图都是我自己一点点画的，希望能对autolayout的一无所知同学有一定帮助，后面我会再更新两篇文章，来结合实际开发来具体讲述下实战中的运用。","tags":[]},{"title":"我的移动开发学习","date":"2016-08-31T12:14:18.000Z","path":"2016/08/31/我的移动开发学习/","text":"现在我是一名准大四计算机学院学生，我的大学并不出色，是属于我们这边比较三流的学校，大一并没有相关专业课程，因此，我的编程生涯可以算是从大二才开始的。 这里还有个小插曲，大一的时候，我大胆得冲进一个老师的办公室，和她说“我要写代码，我要写项目。”所有的一切，都是从我开口说这句话开始。也是因为这句话，我成了她在我们这一届最骄傲的学生（后来发现她并不是我专业的老师，由于跟了她，我也在我们专业被拉入黑名单） 学习之路学习移动开发，是我刚接触智能机的时候就萌发的一个理想，现在，我能为此工作，为此学习，也十分开心。 一切从兴趣入手对于移动开发，在我们学校没有相关专业课程去教学，我的学习之旅也完全是从兴趣入手，当时我特别喜欢ios开发，但是由于学校苹果机房的限制，也听从了导师的安排，首先先开始学习了android开发。 大二由于要参加一些外包，ACM，电商竞赛，也让我不得不进入了疯狂的学习阶段，学习进度在一些学长的带领下，进步很快。 辉煌时刻非常不容易，大二的一年过的很辛苦，各种压力把我压的喘不起来，但是黄天不负苦心人，我在大二那年，也获得了不少成就，在各类省赛中，也拿到了不错的成绩。也成功成为了本届第一批免毕业设计的学生。 膨胀大二一年很快过去，我凭借着手上为数不多的项目，开始找工作，也很顺利在暑期的时候就有了第一份工作，也是在那个时候，开始接触了ios，我也深深被它所吸引，并且在公司，我的学习和上升速度很快，很快就独立完成了第一个在apple store上架的作品。那时候开始慢慢萌发了编程不过如此的想法。 盲目大三开始了，我在辅导员和朋友的鼓舞下，进入了学生干部的生涯，当上了一名部长，也成为一名主席。开始在兼顾工作的同时，监管各种学生事务，开始盲目觉得自己很强。虽然在半年的时间，我也上架了一款app。但是殊不知，我已经开始慢慢堕落了。 打击 第一次打击是在大三下的时候，我带着我的学弟学妹，和我的一个好基友开始了漫长的竞赛，但是没有想到的是，付出了比之前更多的努力，换来的是比之前更差的成绩。 第二次打击，是在一次与一位前辈的谈话中，这位前辈是从海外留学回来的，我当时的想法就是，一个项目，应该尽可能使用开源框架，来节约时间，也更方便开发者去实现，但是他给了我一个微笑，问我，“你说你很熟悉开源框架，那你读过AFNetworking的源码吗？”，说句实话，我当时傻了。 之后的打击也是数不胜数，从一些知名博客，知乎，简书，等等我也知道了很多不足。这里我也举一些例子。 对Objective-C要有足够得了解，OC是如何基于C来进行的封装？ 对于UI,稍微深一点的会了吗？比如，侧边栏的菜单滑出的原理？ 动画会了吗？为什么CALayer会产生隐式动画？ 各种安全机制懂了吗？ …. 我第一次看到上面这些问题的时候，我真的觉得打击很大，也是直到最后，我向各大公司投递简历的时候，简历石沉大海，我才明白了，我还差的很远。 醒悟现在也快大四开始了，相比较其他很多优秀的大四学生，我应该落后了不少，大三这一年，我不能说我完全荒废了，但确实没有什么大的成长，这个假期，我也在一家技术公司工作，在闲余时间，我也学习不少东西，我是因为热爱才去学习，我觉得现在醒悟还不算晚。 最后最后我想说一下，我是一个热爱编程的逗比，平时活得也比较开心，但是我是一个对应用品质很严格的人。我喜欢很多细节把控很好的应用，我也致力于打造这些细节打动用户的应用，之后我会不断更新一些我的学习心得，也会不定期奉上一些酷炫的控件。真正的学习，从现在开始。 第一次写文章，写的不好，请勿见怪。","tags":[]}]